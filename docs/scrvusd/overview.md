<h1>Savings crvUSD</h1>

Savings crvUSD, in short scrvUSD, is a savings version of crvUSD. 


---


# **Smart Contracts**

The Savings crvUSD system consists of multiple smart contracts:

<div class="grid cards" markdown>

-   :logos-vyper: `Vault.vy`

    ---

    The Vault contract is the main contract of the st-crvUSD. It is an `ERC4626` compliant Vault that handles all logic associated with deposits, withdrawals, strategy management, profit reporting, etc.

    [:octicons-arrow-right-24: Getting started](./Vault.md)

-   :logos-vyper: `RewardsHandler.vy`

    ---

    The `RewardsHandler` contract is responsible for taking and storing snapshots of the ratio of crvUSD deposited into the Vault compared to the total circulating supply of crvUSD and calculating the time-weighted average of this ratio using the trapezoidal rule for interpolation. This value is then used to decide on the amount of rewards to "ask for" from the `FeeSplitter`. Calculation is done using a `TWA` module.
    

    [:octicons-arrow-right-24: Getting started](./RewardsHandler.md)

-   :logos-vyper: `StablecoinLens.vy`

    ---

    Helper contract to calculate the true circulating supply of crvUSD by excluding e.g. unborrowed crvUSD from Controllers, crvUSD in PegKeep, etc.

    [:octicons-arrow-right-24: Reference](./StablecoinLens.md)

</div>

The documentation of the :logos-vyper: `FeeSplitter` contract can be found [here](tbd).


---


# **Vault Implementation Details**

The Vault is an unmodified instance of the [Yearn V3 multi-strategy vault](https://github.com/yearn/yearn-vaults-v3) that accepts crvUSD deposits. The crvUSD deposited into the vault are not rehypothecated, they sit idle in the vault to earn yield.

This vault aims to be as cheap as possible for users to deposit and withdraw funds. For this reason funds deposited in the vault are not moved anywhere and are always available to be redeemed.

Although the vault is called "multi-strategy" it actually doesn't contain any strategies. This is possible thanks to yearn vaults' v3.0.3 ability to [report on self](https://github.com/yearn/yearn-vaults-v3/pull/205).


---


# **Rewards**

The Vault receives a dynamic percentage of the interest fees generated by the crvUSD from the `FeeSplitter` contract which is then distributed linearly across all depositors with respect to their share of the total deposits. Inbetween the `FeeSplitter` and the `Vault`, there is a `RewardsHandler` contract that handles the calculation of the dynamic percentage, which is determined by the ratio of crvUSD deposited into the vault over the total circulating supply of crvUSD.

<figure markdown="span">
  ![](../assets/images/stcrvusd/stcrvusd.svg){ width="2000" }
  <figcaption></figcaption>
</figure>


---


# **FeeSplitter Interaction and Weight Calculation**

For the `FeeSplitter` to send funds to the `RewardsHandler`, the `RewardsHandler` must be added as a receiver in the `FeeSplitter` by the DAO. Once this condition is met, the `FeeSplitter` will send funds to the `RewardsHandler` according to what the `weight` function in the `RewardsHandler` returns (this value is dynamic).

The `weight` function allows anyone to take snapshots of the ratio of crvUSD in the vault compared to the circulating supply of crvUSD. This ratio is used to determine the percentage of the fees that can be requested by the `FeeSplitter`.

For instance if the time-weighed average of the ratio is 0.1 (10% of the circulating supply is deposited into the vault), the `FeeSplitter` will request 10% of the fees generated by the crvUSD controllers.


---

# **Rewards Allocation**

Rewards allocated to st-crvUSD come from crvUSD interest fees or any external donations sent to the `RewardsHandler` contract.

The ultimate amount of rewards is dynamic and is determined by the ratio of the staked supply to the total supply of crvUSD. Although it is dynamic, the weight has an upper and lower bound.

Rewards are distributed to st-crvUSD holders thought the `RewardsHandler` contract using a simple `process_rewards` function. This function permnissionlessly lets anyone distribute rewards to the crvUSD vault.

<figure markdown="span">
  ![](../assets/images/stcrvusd/stcrvusd.svg){ width="2000" }
  <figcaption></figcaption>
</figure>

Although the weight is dynamic, it has a upper and lower bound:

1. The lower bound is defined in the `RewardsHandler` contract as `minimum_weight`. This is the minimum percentage of rewards that st-crvUSD will receive.
2. The upper bound is defined in the `FeeSplitter` and represents the maximum percentage of rewards that st-crvUSD will receive from the FeeSplitter. The FeeSplitter allows for dynamic weights, which is the case for st-crvUSD. This upper value can be checked in the `FeeSplitter` contract by calling `FeeSplitter.receivers(i)`, where `i` is the index of the receiver. This method returns the address and the maximum weight of the receiver.

!!!example

    === "Example"

    The weight of the RewardsHandler is equals to 10%. Because the weight of the RewardsHandler is dynamic, these 10% serve as the maximum weight that the RewardsHandler can receive from the FeeSplitter.

    Now, the RewardsHandler contract does some calculations and determins the actual weight. The dynamic weight calculation is based on the ratio of the staked supply to the total supply of crvUSD and the `minimum_weight`. The contract will return the maximum of either the dynamic weight or the `minimum_weight`.

    Therefore, the weight allocated to the RewardsHandler contract will be somewhere in between `minimum_weight` and `10%`. If there is no value set for `minimum_weight`, this value will be treated as 0 meaning the dynamic weight is fully dependant on the ratio of the staked supply to the total supply of crvUSD. 

    For more informations about the calcuation of the dynamic weight, check the [RewardsHandler contract](./RewardsHandler.md).


---


feesplitter -> plug in rewardshandler which supports the dynamic weight interface (EIP-165) of the FeeSplitter, meaning the RewardsHandler contract calculates the actual weight based on some values.

to check if a contract supports an interface, you can use the `supportsInterface` method. This method is part of the EIP-165 standard and is implemented by the RewardsHandler contract.

The amount of funds that this contract should receive from the fee splitter is determined by computing the time-weighted average of the vault balance over crvUSD circulating supply ratio.

The dynamic weight calculation in the RewardsHandler is based on the ratio of the staked supply to the total supply of crvUSD. The weight is determined by the `weight()` function, which is called by the FeeSplitter and based on the `_compute()` function of the TWA module and the `minimum_weight` variable, which serves as a minimum weight[^1].

[^1]: The minimum weight can also be set to 0, which means the weight will be fully dependant on the time-weighted average of the TVL ratio.

```py
return max(twa._compute(), self.minimum_weight)
```

where `twa._compute()` is the time-weighted average of the TVL ratio, and `self.minimum_weight` is the minimum weight that is set to 10% (100000000000000000):

```py
@internal
@view
def _compute() -> uint256:
    """
    @notice Computes the TWA over the specified time window by iterating backwards over the snapshots.
    @return The TWA for tracked value over the self.twa_window (10**18 decimals precision).
    """
    num_snapshots: uint256 = len(self.snapshots)
    if num_snapshots == 0:
        return 0

    time_window_start: uint256 = block.timestamp - self.twa_window

    total_weighted_tracked_value: uint256 = 0
    total_time: uint256 = 0
    # Iterate backwards over all snapshots
    index_array_end: uint256 = num_snapshots - 1
    for i: uint256 in range(0, num_snapshots, bound=MAX_SNAPSHOTS):  # i from 0 to (num_snapshots-1)
        i_backwards: uint256 = index_array_end - i
        current_snapshot: Snapshot = self.snapshots[i_backwards]
        next_snapshot: Snapshot = current_snapshot
        if i != 0:  # If not the first iteration, get the next snapshot
            next_snapshot = self.snapshots[i_backwards + 1]

        interval_start: uint256 = current_snapshot.timestamp
        # Adjust interval start if it is before the time window start
        if interval_start < time_window_start:
            interval_start = time_window_start

        interval_end: uint256 = 0
        if i == 0:  # First iteration - we are on the last snapshot (i_backwards = num_snapshots - 1)
            # For the last snapshot, interval end is block.timestamp
            interval_end = block.timestamp
        else:
            # For other snapshots, interval end is the timestamp of the next snapshot
            interval_end = next_snapshot.timestamp

        if interval_end <= time_window_start:
            break

        time_delta: uint256 = interval_end - interval_start

        # Interpolation using the trapezoidal rule
        averaged_tracked_value: uint256 = (current_snapshot.tracked_value + next_snapshot.tracked_value) // 2

        # Accumulate weighted rate and time
        total_weighted_tracked_value += averaged_tracked_value * time_delta
        total_time += time_delta

    assert total_time > 0, "Zero total time!"
    twa: uint256 = total_weighted_tracked_value // total_time

    return twa
```